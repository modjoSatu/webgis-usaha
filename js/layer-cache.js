(function(){
console.log('[PWA] layer-cache initializing');
const LAYERS=['SLS','PLKUMKM','Matchapro','SWMAPS','KDM'];
const DB='webgis_layers_v1';const VER=1;let idbd=null;
async function openDb(){ if(window.idb && window.idb.openDB){ idbd=await idb.openDB(DB,VER,{upgrade(up){ for(const n of LAYERS) if(!up.objectStoreNames.contains(n)) up.createObjectStore(n); }}); console.log('[PWA] IndexedDB ready'); } else { console.warn('[PWA] idb not found, fallback localStorage'); idbd=null; } }
async function saveLayer(name,text){ try{ if(idbd) await idbd.put(name,text,'data'); else localStorage.setItem('layer_'+name,text); console.log('[PWA] saved layer',name);}catch(e){console.warn('[PWA] saveLayer err',e);} }
async function loadLayer(name){ try{ if(idbd){ const v=await idbd.get(name,'data'); return v;} else return localStorage.getItem('layer_'+name);}catch(e){console.warn('[PWA] loadLayer err',e);return null;} }
function renderText(name,text){ try{ if(!text) return; if(text.trim().startsWith('{')){ const geo=JSON.parse(text); const ly=L.geoJSON(geo,{onEachFeature:(f,l)=>{const p=f.properties||{};const info=Object.entries(p).slice(0,5).map(([k,v])=>`<b>${k}</b>: ${v}`).join('<br>'); l.bindPopup(`<b>${name}</b><br>${info}`);}}); ly.addTo(window.map); console.log('[PWA] rendered geojson',name);} else{ const parsed=Papa.parse(text,{header:true,skipEmptyLines:true}); const grp=L.layerGroup(); let cnt=0; parsed.data.forEach(r=>{ const lat=parseFloat(r.Latitude||r.latitude||r.lat); const lon=parseFloat(r.Longitude||r.longitude||r.lon); if(!isNaN(lat)&&!isNaN(lon)){ L.circleMarker([lat,lon],{radius:3}).bindPopup(`${r.Nama_Usaha||r.nama_usaha||''}`).addTo(grp); cnt++; }}); grp.addTo(window.map); console.log('[PWA] rendered csv',name,cnt);} }catch(e){console.warn('[PWA] renderText err',e);} }
function waitMap(t=10000){ return new Promise((res,rej)=>{ const start=Date.now(); (function p(){ if(window.map && typeof window.map.addLayer==='function') return res(window.map); if(Date.now()-start>t) return rej(new Error('map not ready')); setTimeout(p,300); })(); }); }
async function loadAll(){ await openDb(); try{ await waitMap(15000); console.log('[PWA] loading cached layers'); for(const n of LAYERS){ const t=await loadLayer(n); if(t){ console.log('[PWA] cache found',n); renderText(n,t);} } console.log('[PWA] cached layers loaded'); }catch(e){console.warn('[PWA] loadAll skipped',e.message);} }
function hookFileInputs(){ document.querySelectorAll('input[type=file]').forEach(inp=>{ inp.addEventListener('change',async(e)=>{ const f=e.target.files&&e.target.files[0]; if(!f) return; try{ const txt=await f.text(); let name=null; if(inp.dataset && inp.dataset.layer) name=inp.dataset.layer; if(!name && inp.id){ for(const L of LAYERS) if(inp.id.toLowerCase().includes(L.toLowerCase())) name=L; } if(!name){ const lbl=inp.closest('label')||inp.parentElement.querySelector('label')||inp.parentElement; if(lbl){ const txtlbl=(lbl.innerText||'').toLowerCase(); for(const L of LAYERS) if(txtlbl.includes(L.toLowerCase())) name=L; } } if(!name){ name=prompt('Nama layer untuk file yang diupload (SLS, PLKUMKM, Matchapro, SWMAPS, KDM):'); if(!name) return; name=name.trim(); } if(!LAYERS.includes(name)){ console.warn('unknown layer',name); return; } await saveLayer(name,txt); console.log('[PWA] uploaded file auto-saved for',name); }catch(err){console.warn('file input hook err',err);} }); }); }
window.saveLayerCache=saveLayer; window.loadLayerCache=loadLayer;
document.addEventListener('DOMContentLoaded',()=>{ hookFileInputs(); loadAll(); });
})();